import threading
from dataclasses import dataclass
from typing import Optional, List, Dict
import time


@dataclass
class Job:
    user_id: str
    job_id: str
    priority: int
    submit_time: float = 0.0
    waiting_time: float = 0.0

    def __post_init__(self):
        if self.submit_time == 0:
            self.submit_time = time.time()


class PrintQueueManager:
    def __init__(self, capacity: int = 10, aging_interval: int = 5, expiry_time: int = 20):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front = 0
        self.rear = 0
        self.size = 0
        self.lock = threading.RLock()
        self.job_counter = 0
        self.total_jobs_processed = 0
        self.aging_interval = aging_interval
        self.expiry_time = expiry_time
        self.last_aging_time = time.time()

    def _update_waiting_times(self):
        current_time = time.time()
        if self.size == 0:
            return

        current_index = self.front
        for _ in range(self.size):
            job = self.queue[current_index]
            if job is not None:
                job.waiting_time = current_time - job.submit_time
            current_index = (current_index + 1) % self.capacity

    def _apply_aging(self):
        current_time = time.time()
        if current_time - self.last_aging_time < self.aging_interval:
            return

        if self.size == 0:
            return

        current_index = self.front
        for _ in range(self.size):
            job = self.queue[current_index]
            if job is not None:
                wait_cycles = int(job.waiting_time // self.aging_interval)
                if wait_cycles > 0 and job.priority > 1:
                    job.priority = max(1, job.priority - wait_cycles)
            current_index = (current_index + 1) % self.capacity

        self.last_aging_time = current_time

    def _remove_expired_jobs(self):
        if self.size == 0:
            return

        expired_jobs = []
        current_index = self.front

        for i in range(self.size):
            job = self.queue[current_index]
            if job is not None and job.waiting_time > self.expiry_time:
                expired_jobs.append((current_index, job))
            current_index = (current_index + 1) % self.capacity

        for index, job in reversed(expired_jobs):
            print(f"EXPIRED: Job {job.job_id} from user {job.user_id} removed after {job.waiting_time:.1f}s")
            self._remove_job_at_index(index)

    def _remove_job_at_index(self, target_index):
        if self.size == 0:
            return

        current_index = target_index
        for _ in range(self.size - 1):
            next_index = (current_index + 1) % self.capacity
            self.queue[current_index] = self.queue[next_index]
            current_index = next_index

        self.queue[self.rear - 1 if self.rear > 0 else self.capacity - 1] = None
        self.rear = (self.rear - 1) % self.capacity
        self.size -= 1

    def enqueue_job(self, user_id: str, job_id: str, priority: int) -> bool:
        with self.lock:
            if self.is_full():
                print(f"Queue is full! Cannot add job {job_id} from user {user_id}")
                return False

            current_time = time.time()
            job = Job(
                user_id=user_id,
                job_id=job_id,
                priority=priority,
                submit_time=current_time,
                waiting_time=0.0
            )

            self.queue[self.rear] = job
            self.rear = (self.rear + 1) % self.capacity
            self.size += 1
            self.job_counter += 1

            print(f"Job {job_id} from user {user_id} added to queue (Priority: {priority})")
            return True

    def dequeue_job(self) -> Optional[Job]:
        with self.lock:
            if self.is_empty():
                return None

            self._update_waiting_times()
            self._apply_aging()
            self._remove_expired_jobs()

            if self.is_empty():
                return None

            best_job = None
            best_index = -1
            best_priority = float('inf')

            current_index = self.front
            for i in range(self.size):
                job = self.queue[current_index]
                if job is not None and job.priority < best_priority:
                    best_priority = job.priority
                    best_job = job
                    best_index = current_index
                current_index = (current_index + 1) % self.capacity

            if best_job is not None:
                self._remove_job_at_index(best_index)
                return best_job

            return None

    def print_job(self) -> bool:
        with self.lock:
            job = self.dequeue_job()
            if job is None:
                print("No jobs to print - queue is empty")
                return False

            self.total_jobs_processed += 1
            print(f"PRINTING: Job {job.job_id} from user {job.user_id} "
                  f"(Priority: {job.priority}, Waited: {job.waiting_time:.1f}s)")
            return True

    def is_empty(self) -> bool:
        return self.size == 0

    def is_full(self) -> bool:
        return self.size == self.capacity

    def get_size(self) -> int:
        return self.size

    def get_capacity(self) -> int:
        return self.capacity

    def peek_front(self) -> Optional[Job]:
        with self.lock:
            if self.is_empty():
                return None
            return self.queue[self.front]

    def get_all_jobs(self) -> List[Job]:
        with self.lock:
            self._update_waiting_times()
            jobs = []
            if self.size == 0:
                return jobs

            current = self.front
            for _ in range(self.size):
                if self.queue[current] is not None:
                    jobs.append(self.queue[current])
                current = (current + 1) % self.capacity
            return jobs

    def show_status(self):
        with self.lock:
            self._update_waiting_times()
            print("\n" + "=" * 70)
            print(f"PRINT QUEUE STATUS")
            print("=" * 70)
            print(f"Queue size: {self.size}/{self.capacity}")
            print(f"Total jobs processed: {self.total_jobs_processed}")
            print(f"Aging interval: {self.aging_interval}s")
            print(f"Expiry time: {self.expiry_time}s")
            print(f"Queue Empty: {self.is_empty()}")
            print(f"Queue Full: {self.is_full()}")

            if self.is_empty():
                print("No jobs in queue")
            else:
                print(f"\nCurrent Jobs (Front to Rear):")
                print("-" * 70)
                jobs = self.get_all_jobs()
                for i, job in enumerate(jobs):
                    print(f"[{i + 1:2}] User: {job.user_id:8} | "
                          f"Job: {job.job_id:10} | "
                          f"Priority: {job.priority:2} | "
                          f"Waiting: {job.waiting_time:5.1f}s")

            print("=" * 70 + "\n")

    def get_queue_stats(self) -> Dict:
        with self.lock:
            return {
                'size': self.size,
                'capacity': self.capacity,
                'is_empty': self.is_empty(),
                'is_full': self.is_full(),
                'total_processed': self.total_jobs_processed,
                'front_index': self.front,
                'rear_index': self.rear,
                'aging_interval': self.aging_interval,
                'expiry_time': self.expiry_time
            }

    def force_aging_check(self):
        with self.lock:
            self._update_waiting_times()
            self._apply_aging()
            self._remove_expired_jobs()


if __name__ == "__main__":
    pq_manager = PrintQueueManager(capacity=5, aging_interval=5, expiry_time=20)

    print("Testing Enhanced Queue Management with Aging and Expiry")
    print("-" * 60)

    pq_manager.enqueue_job("Ian", "IT1", 5)
    pq_manager.enqueue_job("Moha", "IT2", 3)
    pq_manager.enqueue_job("Amanda", "SEC1", 4)
    pq_manager.enqueue_job("John", "DOC1", 2)

    pq_manager.show_status()

    print("Simulating time passage for aging...")
    time.sleep(2)

    pq_manager.force_aging_check()
    pq_manager.show_status()

    print("Processing highest priority job:")
    pq_manager.print_job()
    pq_manager.show_status()

    print("Adding more jobs...")
    pq_manager.enqueue_job("Sarah", "IMG1", 4)
    pq_manager.show_status()